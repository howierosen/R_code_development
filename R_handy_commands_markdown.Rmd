---
title: "R_handy_commands"
author: "Howie Rosen"
date: "3/8/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)
```

# CHEAT SHEETS

Master list of all cheat sheets you could ever want: 

https://www.rstudio.com/resources/cheatsheets/

The most useful to start with is probably

https://www.rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-3.pdf

# Created sample datasets

Created several ojects to use as examples for various commands

Created small sample dataset, saved in file named test.frame.csv

It looks like this (commands below read it from a csv file into an object and display the data):

```{r load_show_test.frame}
test.frame.local <- read.csv("test.frame.csv")
test.frame.local
```


Created another sample dataset with 3 categorise, saved in file named test.frame.3c.csv

It looks like this (commands below read it from a csv file into an object and display the data):

```{r load_show_test.frame}
test.frame.3c <- read.csv("test.frame.3c.csv")
test.frame.3c
```

Also creating sample objects

one numeric vector called test.numbers

Looks like this:

```{r make_vector}
test.numbers <- c(2, 10, 30, 70, 90, 110)
test.numbers
```

and the other with strings, a character vector called test.char

Looks like this:

```{r make_char_vector}
test.char <- c("howie", "yann", "gabe", "adam")
test.char
```


# GENERAL R FUNCTIONS

## Open, Close and Directories

### Quit R
  
    quit()
  
### Install Packages
  
    install.packages("package_name")
  
If you want to use the package, you have to give the following command: Library(“package_name”)
    
DON’T FORGET to put “ “ around package name, or it will give you error messages

### Update all installed packages
    
    update.packages()
  
### Getting Help
    
    help(function)
  
e.g. help(plot)
    
OR

?function

e.g. ?plot
    
OR

Apropos(“function”)

Lists all functions with string “function” in the name
  
OR

Example(function)

Gets example of using the function
    
### See current working directory

    getwd()

### List directory contents

    dir("directory_path")

dir() ; this will list contents of current directory

list.files() ; this will do the same thing as dir


### Make new directory

    dir.create(“directory_name”)

Will create new directory in the current working directory

### Remove a directory

    unlink(“directory_name”, recursive = TRUE)

This will remove a directory and everything in it
    
DANGEROUS, this won’t ask you any questions, it’ll just delete it
    
### Change Working directory

    setwd(“directory_path” )

The path has to be in “quotes”. You can use “..” to indicate one directory above

### Run command current line	

    cmd-return
    
    
### List the objects in the current workspace	

    ls( )
    
    OR
    
    Objects( )	
    
ls lists all the objects in the directory, as opposed to list.files or dir, which only list files and other directories

### Display recent commands	
    
    history( )
    
This will display last 25 commands

OR

history( max.show = inf)

This will display all previous commands

### Run a specific script from a file
  
    source(“myfilename”)

If no filename or path is specified, will look in current directory


## Working with data files

###	Import a data file, like a .csv file

    mydata <- read.table( “path\mydata.csv” , header = TRUE, sep = “,” , row.names =“id”)
    
OR

mydata <- read.csv(“path\datafile.csv”)

This is if you know the file is a csv file

You can read in other types of files if you indicate a different separator, for instance, for a tab separated file you would do:
    
mydata <- read.table( “path\mydata.tsv” , header = TRUE, sep = “\t”, row.names=“id”)

DON’T FORGET  to use the header and sep arguments and to include the .csv or it won’t read the file in correctly

### Import a .csv file, if you know it’s a .csv file
      
      mydata <- read.csv( “path\mydata.csv” , header = TRUE, row.names = “id”)
  
Here, you don’t have to specify the separator, cause it assumes comma separated


### Export to a .csv file

    write.table ( mydata, “path\mydata.csv”, sep = “ ,“ )

OR

To write to a tab separated file

write.table ( mydata, “path\mydata.csv”, sep = “ \t“ )

**BE VERY CAREFUL!**

**DON’T FORGET**  to use the header and sep arguments and to include the .csv or it won’t write the file correctly and might overwrite your old file and mess it up.

**BEST NEVER TO WRITE FROM R TO A FILE THAT ALREADY EXISTS AS A CSV FILE**

### Import a stata file

    library(foreign)
    mydata <- read.dta( “mydata.dta” )

### Export to a stata file

    library(foreign)
    write.dta(mydata,  “path/mydata.dta” )


### Make a new file

    file.create(“filename”)

e.g.

file.create(“myfile.R”)

this will create a file that R will recognize as an R file

### Check whether a file exists

    file.exists(“filename”)

Useful for programming to make sure a file exists before the program uses it

### Rename a file

    file.rename (“old_name”, “new_name”)


### Get info on a file	

    file.info(“filename”)

## Saving and Loading Output

### Save  and Load dataset	

    save(object1_tobesaved, object2_tobesaved,..., file  = ‘filename’)

    load( ‘filename’)
e,g.

save(staff.data, file=’staffdata.RData’

load(‘staffdata.RData’)	

In this case, we are saving an object that happens to be a data frame and loading it. You can also save other objects such as lists or vectors, all in the same file, you just separate each object from the next using a comma

### Attaching data frame to avoid having to preface each query with the data frame name	

    Attach(frame_name)
    detach(frame_name)

e.g.

attach(staff.data)

staff.data[age > 30, ]

  name |  height  | age
  -----|----------|-----     
1 howie|  short   | 51
2 yann |  tall    | 40

e.g.

height

[1] short tall tall

Levels: short tall

### Save all objects in current working directory	

    save.image()
    
This saves all objects in the current working directory. 

These objects will automatically be loaded when you open R in this directory

Saves objects in a file called  .RData 

### Saving your recent commands	

    savehistory ( file = “myfilename”)

The default is to save in a file called .Rhistory

### Loading your recent commands	

    loadhistory ( file = “myfilename”)

the default is to save in a file called .Rhistory

### Direct output to a specific location/file

    sink(“myfilename”, append=FALSE, split=FALSE)
    
    sink() ; This latter command returns output to terminal

### Direct graphic output to a location/file	

    jpg(“myfilename.jpg”)
    
    This will output the graph to a jpg file
    
    dev.off( )
    
    The tells R to redirect output back to terminal

Instead of jpg, can also say:

pdf (“myfile.pdf”)

bmp (“myfile.bmp”)

png (“myfile.png”)

postscript (“myfile.ps”)

## Writing Functions

### Format of a function	

    Function_name <- function(arguments) {
     Operations
     return output
    }	

Arguments are usually values that are given to the function, which could be numbers, variables with numbers in them, and paramters

### Saving output of a function	

    Output_object <- function_name(arguments)

Key is that you have to remember that the objects you make in a function, or modifications to objects that you make, only exist within the function unless you save the output of the function as an objects

e.g.

frame.with.new.column <- function_that_adds_column(frame.without.new.column)

### Saving a function in R studio	

    Write it in the top left window
    Check source on save
    Hit save 

### To write a function that will take a column name as an argument	

    Use double square brackets [[ ]] to refer to the column in the function, instead of the $
    
    Have to pass the column name as argument in quotes when you call the function

e.g.

function_name <- function(data.frame.name, “column_name”) {
       
result_variable <-  function(data.frame.name                    [[column_name]][element_number]
      
}

e.g.

```{r makemean}
newmean <- mean(test.frame.local[["age"]])
newmean
```

NOTE: you have to remember to put the name of the column in quotes: " "

OR, here it is using a function that takes the column name as an argument:

makemean <- function(frame.name, column) {

  average <- mean(data.frame[[column]])

}

if you call this function using the variable age, this function will take the mean of the column labeled age and store it in the object called average. 

Like this: makemean(frame.name, “age”)

OR

e.g.

getsecondvalue <- function(frame.name, variable){
      
second <- frame.name[[variable]][2]

}

if you call this function using the variable age, this function will get the second observation in the column labeled age and store it in the object called second. Like this: getsecondvalue(frame.name, “age”)

###Control functions	
    
    If-else
    if (cond) expression
    if (cond) expression1 else expresssion2

    OR
    
    for (var in seq) expresssion

    OR
    
    While (cond) expression
    
    OR
    
    ifelse (test, yes, no)


### Logical Operations	

    & (and, specifies conjunction, e.g. if number meets condition 1 and condition 2)
    
    | (or, specifies dysjunction, e.g. if number meets condition 1 or condition 2)
    
    == (for identifying values for classifying, this is like saying “is equal to”, and evaluates whether both sides of the operator are the same)
    
    = (for equations)
    
    != (is not equal to)
    
    && and || will only evaluate the first expression on the one side of the operand:
    
    e.g.
    
    TRUE & c(TRUE, FALSE, FALSE)
    
    TRUE FALSE FALSE

    TRUE && c(TRUE, FALSE, FALSE)
    
    TRUE

# GENERATING DATA

## Making Objects and Vectors

### Storing an object	

    Object_name <- data to be stored

e.g. x <- 100

This will store the number 100 in the object named x

Typing the name of the object will show the contents

e.g. 

x

[1] 100

Object names can contain numbers, letters and periods

Object names are case sensitive

Each object is by definition a vector

Objects can have numbers, logical values (e.g. true false), characters, complex numbers

Character data must be surrounded by quotes

### Remove object from memory	

    rm(object_name)
    
    rm(list = object1, object2, ...)
    
    latter removes multiple objects

### Remove ALL objects from memory	

    rm(list = ls())

### Combine arguments into a vector	

    c(element1, element2, element3, …)

e.g.  x <- c(1, 9, 3, 5, 9)

x

[1] 1 9 3 5 9

This puts all those numbers in the object x. Typing the name of the object will tell R to list the elements in the vector, starting with the first one, which is what the [1] means

**Need commas** between elements  going into the object

All elements in the vector must have the same mode

Vector can include NA, for missing data

### Cut a continuous variable into a factor variable	

    equal.count(dataset_name$variable, number=#, overlap = #/#)

e.g.

agegroups <- equal.count(my.data$age, number =4)

This command will take the age variable and cut it into 4 equally sized groups and save the group designation as a nominal factor variable with 4 levels called agegroups

### Paste together or concatenate strings

    paste(“string1”, “string2”, “string3”, …, sep = “ “, collapse = NULL)

sep tells the function what character to use to separate the strings

### Place value in a particular element location in a vector	

      Object_name[element_number] <- value

e.g. x[7] <- “great”

This will put the word “great” in the 7th element in the vector called x

### Making factors	
    
      factor(object_name)

e.g.  x <- c(“m”, “m”, “m”, “f”, “f”)

x <- factor(x)

x

[1] m m m f f

level: f m

you can do this more efficiently like this:

x <- factor(c(“m”, “m”, “m”, “f”, “f”)

if your vector only happens to have one value, but you want to preserve the ability to have multiple levels, you have to specify that

x <- factor(c(“m”, “m”, “m”), levels = c(“f”, “m”))

x

[1] m m m

levels: f m

### Generating names for elements	

      Names(object_name) <- (“element_name1” “element_name2, “element_name3”, …)

e.g.

x <- c(15 13)

names(x) <- c(“eli”, “jonah”)	

Can  also use this to rename all the variables in a dataset, but you must enter names for every variable

### Generating labels for values in a vector

      mydata$v1 <- factor(mydata$v1,levels = c(1, 2, 3), labels = c( “young”, “middle-age”, “old” )

OR if data are ordinal instead of factor variable

mydata$v1 <- ordered(mydata$v1,levels = c(1, 2, 3), labels = c( “young”, “middle-age”, “old” )

### Vector operations	

      operation(object_name)

e.g. 

v

[1] 3 5 10

If the object v has 3 elements, the command below will multiply each element by 2, and the new values will be placed in object x

x <- 2*(v)

x

[1] 6 10 20

Doing operations where one vector is combined with another will result in the operation being done for the corresponding element location in the two vectors

e.g. 

v

[1] 3 5 10

y

[1] 5 10 10

z <- v+y

z

[1] 8 15 20	

When doing operations with 2 vectors, if they are not the same length, R “recycles” elements in the shorter vector staring with the first element

### Generate numbers from a normal distribution	

      rnorm(number_values, mean = #, sd = #)

e.g.

rnorm(100, mean = 50, sd = 10)

This command will create a vector with 100 random numbers from a normal distribution with a mean of 50 and standard deviation of 10

### Recode data into a factor variable	

      Datafilename$newfactorvariablename[existingcontinuousvariablename criterion]  <- “factorlevelname” 

This example will make a new factor variable agecat that will make levels corresponding to three age ranges

attach(mydata)

mydata$agecat[age > 75] <- "Elder"

mydata$agecat[age > 45 & age <= 75] <- "Middle Aged"

mydata$agecat[age <= 45] <- "Young"

detach(mydata)

### Centering a variable	

      scale(variable_name, center = TRUE, scale = FALSE)

### Generating z-scores	

      scale(variable_name, center = TRUE, scale = TRUE)
      
### Changing a string to a date

      object_name <- as.date(date_variable, format)

e.g.

strDates <- c("01/05/1965", "08/16/1975")

dates <- as.Date(strDates, "%m/%d/%Y")

ALSO

If you want to calculate time between datesXXXXX	

Dates are represented as the number of days since 1970-01-01, with negative values for earlier dates

If string is indicated by capital letter, it indicates longer/unabbreviated version, for instance %Y is YYYY, %y is yy. %A is full weekday name (like Monday) and %a is abbreviated weekday name, like Mon.

### Generate a sequence	

      seq()

This command can be used in several ways:

Seq( start_number, end_number, length = number)

e.g. seq( 0, 10, length =3)

[1] 0 5 10

this generates a sequence of numbers between 1 and 10 such that the length of the resulting vector is 3

OR

Seq( start_number, end_number,  by = number)

e.g. seq( 0, 10, by =2)

[1] 0 2 4 6 8 10

this generates a sequence of numbers between 1 and 10 counting by 2

OR

Seq(starting_number, ending_number, interval)

e.g. seq( 0, 2, 0.5)

[1] 0.0 0.5 1.0 1.5 2.0

### Generate a repetitive sequence	

      rep( number, repeats)

e.g. rep( 10, 5)

[1] 10 10 10 10 10

you can also do it with sequences

e.g. rep( 1:3, 3)

[1] 1 2 3 1 2 3 1 2 3

OR you can have each number in the sequence repeated

e.g. rep( 1:3, each = 3)

[1] 1 1 1 2 2 2 3 3 3

### Generate repetitive values within factors	

      gl( number of levels, repeats in each level)

e.g. gl( 3, 4)

[1] 1 1 1 1 2 2 2 2 3 3 3 3

levels: 1 2 3

another example with character data

e.g. gl( 2 , 3, labels = c(“m”, “f”))

[1] m m m f f f

levels: m f

### Generate random numbers	

    rfunction( number_of_data, parameters)

e.g. rnorm(5)

[1]  1.2241399  0.8170304 -0.2244951 -0.3439073  1.2656202

this generates 5 random numbers from a normal distribution with a mean of 0 and sd of 1. You can change the parameters of the distribution you draw from

e.g. rnorm(5, mean = 10, sd = 3)

[1] 14.642944  7.436970 12.740121  9.238453  4.280766

### Grab a random sampling of data from a vector	

      Sample(“variable_name”, number)

e.g. sample(my.data$height, 4)

this command will take 4 random values from the variable height
You specify the number of elements you want to grab

OR

e.g.

Sample(1:6, 4, replace = TRUE)

This will grab 4 random values from the sequence 1:6. The replace=TRUE argument says you can grab the same observation/number more than once

OR

e.g.

sample(my.data$height)

This command will randomly rearrange all the values in the variable height. It will “sample” all the values because a number to sample was not specified


OR

e.g.

Sample(c(0, 1), 100, prob = c(0.3, 0.7), replace = TRUE)

This command will grab 100 values from the vector containing 0 and 1, with a probability of grabbing 0 being 0.3 and the probability of grabbing 1 being 0.7. In this command, you had to say replace = TRUE because you don’t have 100 observations in the vector, so you have to replace the value each time you grab it

## Making Matrices and Data Frames

### Separate vector into matrix	

      dim(object_name) <- (nu_of_rows, nu_of_columns)

e.g.

x <- c(1, 2, 3, 5, 10, 14, 19, 22)

dim(x) <- c(2, 4)

[1] 1 3 10 19

[2] 2 5 14 22

### Create a matrix	

      Object_name <- matrix (c(element1, element2, …), nu_rows, nu_columns)

e.g.

x <- matrix (c(1, 2, 3, 5, 10, 14, 19, 22), 2 ,4)

x

[1] 1 3 10 19

[2] 2 5 14 22

OR

Object_name <- matrix (c(element1, element2, …), no_rows, no_columns, byrow = T)

e.g.

x <- matrix (c(1, 2, 3, 5, 10, 14, 19, 22), 2, 5, byrow = T))

x

[1] 1    2   3   5

[2] 10 14 19 22	

If you make a matrix with the standard command, R will fill the column with consecutive values and go to the next column. If you want to fill a whole, then move to the next, use the byrow = TRUE parameter.

### Generating names for columns and rows in a matrix	

      colnames(matrix_name) <- c(“column_name1” “column_name2, “column_name3”, …)

      rownames(matrix_name) <- (“row_name1” “row_name2, “row_name3”, …)

e.g.

x <- matrix (c(1, 2, 3, 5, 10, 14, 19, 22), 2, 5, byrow = T))

colnames(x) <- c(“visit1”, “visit2”, “visit3”, “visit4”)

rownames(x) <- c(“wait1”, “wait2”)

x

waits visit1  visit2  visit3 visit4

wait1    1          2          3        5

wait2    10       14       19      22

You can also save the column names or row names in variables and use them

e.g.

cnames <- c(“visit1”, “visit2”, “visit3”, “visit4”)

colnames(x) <- cnames

### Change name of a column in a dataframe	

      colnames(data.frame)[col_number] <- “new_name”

### Join two vectors/matrices by columns	

      cbind(object_name, object_name)

e.g.

x

[1] 1    2   3   5

[2] 10 14 19 22

y

[1] 3    3

[2] 4    5

cbind(x[ ,4], y[ ,1])

*spacer*    [ , 1]  [  ,2] 

[1, ]        5        3

[2,  ]      22       4

### Join two vectors/matrices by rows	

      rbind(object_name1[position], object_name2[position])
e.g.

x

[1] 1    2   3   5

[2] 10 14 19 22

y

[1] 3    3   4   9

[2] 4    5   10  20

rbind(x[ 1, ], y[2, ])

*spacer*    [ , 1]  [  ,2]   [  ,3]   [  ,4]
[1, ]       1        2         3         5
[2, ]       4       5         10       20

### Creating a data frame	

    Dateframe_name <- data.frame(object1_name = c(value1, value2, …), object2_name = c(value1, value2, …), object3_name = c(value1, value2,…)

e.g.

staff.data <- data.frame(name = c(“Howie”, “yann”, “gabe”), height = c(“short”, “tall”, “tall”), age = c(51 40 24))

*sp* name   height   age

1   howie   short    51

2   yann      tall       40

3   gabe      tall        24

If already created the name, height and age variables, can just do this:
Staff.data <- c(name, height, age)

### Adding columns to a data frame	

      Frame_name$new_variable_name <- c(value1, value2, …)

e.g.


staff.data$howmuchhair <- c(“not much”, “a lot”, “a lot”)

staff.data

*sp* name   height   age  howmuchhair

1   howie   short    51    not much

2   yann      tall       40    a lot

3   gabe      tall        24   a lot

### Adding columns to a data frame other ways	

      data$size <- c("small", "large", "medium") 
      data[["size"]] <- c("small", "large", "medium") data[,"size"]  <- c("small", "large", "medium") 
      data$size      <- 0
      
### Move a column from one location to the beginning of a dataset	

      example
      col_idx <- grep("string", names(dataset))
      dataset <- dataset[, c(col_idx, (1:ncol(dataset))[-col_idx])]
      names(dataset)

Here, you are using grep to find the location of the columns with names containing the “string” you have specified, you save those locations to an objects, then you rewrite the dataset using data from all rows of the dataset in the columns saved in col_idx first, and then all other columns in the dataset excluding those at the positions saved in col_idx.

### Sorting data	

      Newdata <- my.data [order (mpg), ]
Above command will sort all the data in my.data by the variable mpg and save the sorted data to a new variable, “newdata”

      Newdata <- my.data [order (mpg, cyl), ]
Above command will sort all the data in my.data by the variable mpg and then the variable cyl and save the sorted data to a new variable, “newdata”

      Newdata <- my.data [order (mpg,  - cyl), ]
Above command will sort all the data in my.data by the variable mpg in ascending order and then the variable cyl in descending order and save the sorted data to a new variable, “newdata”

### Remove rows from a data frame	

      Dataset_name <- dataset_name [ -c(row#, row#...),  ]
      
### Creating a list	

      List_name <- list(object1_name = value, object2_name = value, object3_name = value, …)

e.g.

howie.lst <- list(stud.id = 3344, stud.name = “Howie”, stud.scores = c(99, 73, 95, 85)

howie.lst

$stud.id

[1] 3344

$stud.name

[1] “Howie”

$stud.scores

[1] 99 73 95 85	

A list contains several objects. The objects don’t have to have the same length or mode

### Naming objects in a list	

      Names(List_name) <- c(“name1”, “name2”, “name3”, etc.)

e.g.

names(howie.lst <- c(“id”, “name”, “scores”)

Howie.lst

$id

[1] 3344

$name

[1] “Howie”

$scores

[1] 99 73 95 85

### Extending a list (adding new objects)	

      List_name$object_name <- c (value1,  value2, etc.)

e.g.

Howie.lst$parents <- (“dora”, “seymour”)

Howie.lst

$id

[1] 3344

$name

[1] “Howie”

$scores

[1] 99 73 95 85

$parents

[1] “dora” “Seymour”


### Concatenating lists	

      New_list <- c(list1, list2)

e.g.

list2 <- c(age = 51, sex = “man”)

new.lst <- c(Howie.lst, list2)

new.lst

$id

[1] 3344

$name

[1] “Howie”

$scores

[1] 99 73 95 85

$parents

[1] “dora” “Seymour”

$age

[1] 51

$sex

[1] “man”

### Unflatten a list	

      unlist(listname)	
      
All list elements will become elements in a single vector, and be forced to have the same mode (e.g. character, numeric…), and each element will have a name


# EXAMINING DATA

## Examining Objects, Vectors

### Reading an object
    
      View(object_name)
      
### Find length of an objects	

      length(object_name)

e.g.  

x

[1] 1 9 3 5 9

length(x)

[1] 5


### See the type of an object	

      Class(object_name)
Above command will return data.frame if it’s a dataframe, numeric if it’s numeric, etc…

As compared with mode, class seems more useful to tell you what properties an object has, what you can do to it and what you can't

### Find type of data in objects	

      mode(object_name)
If you want to know if a vector is character vs integer vs float, use mode

e.g.  

x

[1] 1 9 3 5 9

mode(x)

[1] “numeric”


### See the dimensions of an object	

      dim(object_name)
      
remember can also use dim to seaprate a vector into a matrix (see generating data)

### Evaluate whether two arguments are identical	

      identical(argument1, argument2)
e.g.

identical(7, 7)

TRUE

This can help you decide whether the contents of two objects are the same

### Evaluate two arguments and return TRUE if they are not both true or both FALSE	

        xor(argument1, argument2)

This function will return TRUE if one argument is FALSE and one argument is TRUE. If both are TRUE, or both are FALSE, the function will return FALSE
e.g.

xor(7>7, 3==3)
TRUE

### Find the value for an element in a vector	

      Object_name[element_number]

e.g. x[7]

This will show the value of the 7th element in the vector called x

e.g.

x[length(x)]

This will find the value of the last element in a vector, regardless of how long it is

### List levels in a factor variable

      levels(dataset_name$variable_name)
      
### Look at factor level as its integer	

      as.integer(dataset_name$variable_name)
      
### Look for a particular string  in a dataset	

      grep(“string”, object)

e.g.

myname <- grep(“Howie”, namelist)

This would find the position of the name howie in a column of names and assign it to the variable myname	The variable myname would not have the string “Howie” in it, just the row number or column number where it is in the larger dataset


### Get descriptors for a variable	

      mean(dataset_name$variable, na.rm = TRUE)
      median(dataset_name$variable, na.rm = TRUE)
      min(dataset_name$variable, na.rm = TRUE)
      max(dataset_name$variable, na.rm = TRUE)
      sd(dataset_name$variable, na.rm = TRUE)

Using na.rm = T means you should leave NA observations out of the equation



## Examining Matrices, Dataframes

### Counting columns and rows in data frame	
    
      ncol(frame_name)
      nrow(frame_name)

### Read beginning and ends of datasets	

      Head(dataset_name)
      Tail(dataset_name)

OR

Head(dataset_name, #rows)

Tail(dataset_name, #rows)

To specify the number of rows to be shown (instead of the default 6)

### List names of variables in dataset	

      names(dataset_name)

### List variables in dataset with info about each	  
      
      str(dataset_name)
      
Give a bit about type of each variable, and initial few values

### Summarize properties of variables in dataset

      summary(dataset_name)

For numeric variables, will give mean, median, max, min and 1st and 3rd quartiles

For character variables, will give counts for each level

### lappy: Apply functions to multiple elements in an object

    lapply(dataset_name, function, na.rm = TRUE)

NOTE: lapply always returns a list, which will have a bunch of elements, each of which corresponds to the element that was evaluated in the original dataset

One major value of using lapply is to do a function iteratively without having to write a loop code

e.g.

```{r lappy_test_frame_all}

lapply(test.frame.local, mean)

```


This command will try to take the mean of every column in the dataset. Note it gives warnings for the character variables, cause you can't get a mean. 

NOTE that apply wants to work on each element in a vector, so if you give it only one column out of the data frame, it will take the mean for every value in the column separately, like this:

```{r lapply_age}

lapply(test.frame.local$age, mean)

```

BUT, you can subset a couple of columns and do what you want, like this:

```{r lapply_age_vol1}

lapply(test.frame.local[c("age", "volume1")], mean)

```


Other functions include sd, var, min, max, median, range, and quantile, or any other function


### sapply: Apply functions and get the result formatted properly	

      sapply(dataset_name, function, na.rm = TRUE)
NOTE: sapply is like lapply but better because it will return simplify the data into the simplest data structre possible, like a simple vector or matrix if it can

If using sapply results in a bunch of elements of length 1, it will save them in a vector

If using sapply results in a bunch of vectors that all have multiple elements and have the same length, it will save them in a matrix.

If using sapply results in a bunch of vectors that all have multiple elements that are not the same length, it will save the results as a list, which is the same thing that lapply will do

e.g.

means <- sapply(my.data, mean, na.rm = TRUE)

This command will try to take the mean of every column in the dataset my.data, and save those means in a vector. Because the output of mean is numbers, the vector will be numeric

e.g.

class_list <- sapply(my.data, class)

This command will assess the class of each column in the my.data dataset and pass the class values to a vector called class_list. Because the output of class is a string, the vector will be a character vector

sapply will also make a matrix if the data it brings back is a series of vectors

e.g.

maxmin <- sapply(my.data, range)

This will take the minimum and maximum of the numbers in each column of my.data and save it in a matrix that would be 2 rows by however many columns are in the dataset

### vapply: Specify the type of output provided by apply	

      vapply(dataset_name, function, vector_type)

e.g.

vapply(my.data, class, character(1))

This command will determine the class of each object in my.data and the output is specified as a character vector of length 1.	

Using this function does the same thing as sapply, but it is ‘safer’ than sapply because it will give an error if the output is not in the form you expect. Thus, vaapply is good to use in scripts where you want error messages if things don't go well. In contrast, sapply will output the result in whatever format it needs to, and you won’t know if it’s not what you expect

### tapply: Get statistics for an object in a list split according to another factor vector	

      tapply(variable_to_be_assessed, factor_variable, function)

e.g.

tapply(my.data$age, mydata$diagnosis, mean)

this command with provide the means for the variable age at each level of diagnosis

### Extract value of an element from a list 	

      List_name[[list_item_number]]

e.g.

howie.lst[[3]]

$stud.scores
[1] 99 73 95 85

OR

List_name$object_name

e.g.

howie.lst$stud.scores

[1] 99 73 95 85	

If you just use single brackets, you will just create a new list based on the object you have queried (in this case, the third object). If you want the value of an element, you have to use the double brackets

### Make tables for factor data	

      table(Object_name)

e.g.

```{r count_sex}

table(test.frame.local$sex)

```


you can also use table to cross-tabulate multiple factors for the same cases. For instance if you also have a second factor with age categories for the same people references in x, you can show sex and age in a table

e.g.

```{r count_sex_by_dx}

table(test.frame.local$sex, test.frame.local$dx)

```


### Getting frequencies from cross-tabulated data	

First put the table in an object

      prop.table(table_object_name, dimension_number)

e.g.

```{r prop_table_sex}
# first put the data into a table
sex_table <- table(test.frame.local$sex, test.frame.local$dx)
# then run the command to make proportions, use the second argument to say which dimension of the table to use, the first or the second
prop.table(sex_table, 1)

```
This set of commands gives you the proportions of other levels within each level of the first dimension in the table, which is sex, and says that 70% of the females are BV and 30% are CON, and 36% of the males are BV and 64% are CON

OR

e.g.

```{r prop_table_BV}
# first put the data into a table
sex_table <- table(test.frame.local$sex, test.frame.local$dx)
# then run the command to make proportions
prop.table(sex_table, 2)

```

This gives you the proportions of other levels within each level of the second dimension in the table, which is dx, and says that 55% the BVs are female adn 44% are male, and 22% of the CONs are female and 78% are male

OR

e.g.

```{r prop_table_all}
# first put the data into a table
sex_table <- table(test.frame.local$sex, test.frame.local$dx)
# then run the command to make proportions
prop.table(sex_table)

```

This gives you the proportions with respect to all categories, and says that 27% of all the people are BV females, 11% are CON females, 22% are BV males and 39% are CON males

OR

You can run the prop.table command with the table command:

e.g.

```{r prop_table_short_all}

prop.table(table(test.frame.local$sex, test.frame.local$dx))


```

### Getting percentages from cross-tabulated data	

      prop.table(table_object_name, dimension_number)*100

e.g.

```{r prop_table_short_all_pct}

prop.table(table(test.frame.local$sex, test.frame.local$dx))*100


```

### Getting marginal counts from cross-tabulated data	

      Margin.table(table_object_name, dimension_number)

```{r margin_table_sex}

margin.table(table(test.frame.local$sex, test.frame.local$dx), 1)


```

OR

e.g.

```{r margin_table_dx}

margin.table(table(test.frame.local$sex, test.frame.local$dx), 2)


```


## Subsetting various ways

### Get value at a specific position in a vector

      Object_name[position]

e.g.

```{r get_name}

test.char[2]

```      


### Get values at multiple positions in a vector	

      Object_name[c(position, position, …)]

e.g.

```{r get_names}

test.char[c(2,4)]

```   

You have to combine the positions into a vector or it will think you are looking at a matrix and get confused

OR

      Object_name[c(sequence)]
e.g.

```{r get_some_names}

test.char[c(2:4)]

``` 

OR, designate a position to ignore

      Object_name[-position_to_ignore]
      
```{r leave_name_out}

test.char[-4]

``` 

OR, designate multiple positions to ignore

      Object_name[-c(position, position, …)]

```{r leave_names_out}

test.char[-c(2,4)]

``` 

this last command uses the negative sign to tell R to give the elements in the object, ignoring the specified positions

### Get values at specific position in a matrix	

      Object_name[row_position, column_position]

e.g.

```{r get_dx}

test.frame.local[2,4]

``` 

OR

To list all the values in a particular variable in a data frame:
      
      frame_name$object_name
      
      OR
      
      frame_name[["object_name"]]
When using the double square brackets, you have to put the name in quotes, when using the $ you don't

e.g.

```{r list_dxs}

test.frame.local$dx

```

OR

```{r list_dxs_square}

test.frame.local[["dx"]]

```

### Get a whole row

      Object_name[rownumber, ]

e.g.

```{r show_pidn}

test.frame.local[3,]

```


OR, get multiple rows

e.g.

```{r show_pidns}

test.frame.local[2:3, ]

```

### Get a whole column

      Object_name[ , columnnumber]
      Object_name[ , "columnname"]

e.g. 

```{r show_ages}

test.frame.local[,2]

```

OR, get multiple columns

e.g.

```{r show_multiple_features}

test.frame.local[,2:4]

```

e.g.

```{r show_ages2}

test.frame.local[,"age"]

```



### Get values from a matrix and keep the result as a matrix instead of a vector	

    Object_name[row_position, column_position, drop = FALSE]



If you do this command and do not include the drop =FALSE parameter, R would just make a vector, not a matrix because the result would have just one row of values

### Identifying elements that meet specific criteria	
      
      Object_name[test]
e.g.

```{r get_nums_gt_10}

test.numbers
test.numbers[test.numbers>10]

```

this command gave us the elements in object test.numbers that was greater than 3

### Querying data frame using conditions	

    Frame_name[frame_name$variable_name condition]

e.g. 

To get all columns where the row value for age is more than 60

```{r get_age_gt_70}

test.frame.local[test.frame.local$age < 60, ]

```

OR

e.g.

To get all columns where the row value for dx is BV

```{r get_dx_BV}

test.frame.local[test.frame.local$dx == "BV", ]

```


OR

e.g.

OR

e.g.

To get only the age for those where the dx is BV

```{r get_age_dx_BV}

test.frame.local[test.frame.local$dx == "BV", "age"]

```


To get only the age and volume1 value for those where the dx is BV

```{r get_age_vol_dx_BV}

test.frame.local[test.frame.local$dx == "BV", c("age", "volume1")]

```


### Probe elements in a vector to get the **positions** of those meeting certain criteria	

      which(object_name criterion)

e.g.

```{r get_row_psn_BV}

test.numbers
which(test.numbers > 10)
which(test.char == "gabe")

```


### See if any elements in a dataset meet specific criteria	

      any(object_name criterion)

e.g.

x <- c(1, 3, 8, 10)

any( x > 7)

TRUE

### See if all elements in a dataset meet specific criteria

      all(object_name criterion)

e.g.

x <- c(1, 3, 8, 10)

all( x > 7)

FALSE


### Subsetting one or more columns based on the name	

      Object_name[“element_name”]
If you want to get the values of a whole column based on the column name, you can do this

```{r get_col}

test.frame.local[c("PIDN","age")]

```

### Subsetting rows in a data frame	

      subset(frame_name, condition)
      
      OR, to combine multiple conditions, using |, which is "or":
      
      Subset(frame_name, variable1==condition | variable1==condition)

e.g

```{r get_PIDNs}

subset(test.frame.local, test.frame.local$PIDN==4444 |  test.frame.local$PIDN==6666)

```


### By function: Apply a function to some data according to levels of another variable	

      by(data, factor_variable, function) 
e.g.

```{r mean_age_by_dx}

by(test.frame.local$age, test.frame.local$dx, mean)

```


### With function: Apply a function to some data specifying the data that goes into the function (or limiting the input)	

      with(data, expresssion) 
e.g.

```{r mean_age_con_only}

with(test.frame.local[test.frame.local$dx=="CON", ], mean(age))

```

this command with provide the mean for the variable age for those with a diagnosis of CON

the "with" command sets the environment in which to do the operation. Here, we are telling it what data frame to use, then within the square brackets we are specifying the dataset to create in which to run the analysis, meaning a new dataset made up of all columns for the rows where the dx variable has a value of BV

### Aggregating data	

        Newobject <- aggregate(variables_to_aggregate ~ variable1_for_grouping + variable2_for_grouping, data=data.frame, FUN=function, na.rm=TRUE)
        
        OR
        
        Newobjects <- aggregate(data=data.frame, by = list (factor_var1, factor_var2…), FUN = function, na.rm = TRUE)

e.g.

``` {r agg_means_dx_alt}

aggregate(test.frame.local$age ~ test.frame.local$dx + test.frame.local$sex, FUN=mean)

```

OR

e.g.

``` {r agg_means_dx}

aggregate(test.frame.local$age, by = list(test.frame.local$dx, test.frame.local$sex), FUN=mean)

```


OR, example with more concise code

agg_gap_country <- aggregate(.~country, data=gapM, FUN=mean)

Here, you are getting the mean of all the variables in the dataset gapM, divided according to country. The . means all, the ~ means by.

### Find observations with missing data in a variable of interest	

      is.na(dataset_name$variable)

or can find lines where the variable of interest is not missing

!is.na(dataset_name$variable)

### Omit observations with missing data

      na.omit(dataset_name$variable)

### Identify rows with NA values in ANY of the variables in the row	

        complete.cases(dataset_name)
e.g.

my.data[complete.cases(my.data), ]

This command will extract the rows that have complete data in the my.data dataset

e.g.

my.data[ ! complete.cases(my.data), ]

This command will extract the rows that DO NOT have complete data in the my.data dataset

The complete cases command returns a vector with one line for each line in the data frame, and the value TRUE for those lines that are complete

# HYPOTHESIS TESTING

## Chi-square

### Run a Chi-square	

      summary(table_data)
      
```{r chi_sq}

summary(sex_table)

```

If you run the summary command on data that is in a table, it will run a chi square

## Correlation

### Run correlations between variables in dataset

      cor(variable1, variable2, method= "pearson", alternative = "two.sided"")
      
      OR
      
      cor(dataset [row, column], use = “complete.obs”)

e.g.

```{r corr}

cor(test.frame.local[ , c("volume1", "volume2")], use="complete.obs")

```

The “complete.obs” tells R to disregard observations with NA. The command will produce a correlation matrix between all indicated variables. Can actually run without the method and alternative arguments, and it will run pearson and two-sided t.test by default.

Can use method = "kendall" or method = "spearman" for non-parametric correlations (see discussion below for cor.test)

### Run pearson correlation with test stats

      cor.test(variable1, variable2, method= "pearson", alternative = "two.sided"")

```{r corr_test}

cor.test(test.frame.local$volume1, test.frame.local$volume2, method = "pearson", alternative = "two.sided")

```

Can actually run without the method and alternative arguments, and it will run pearson and two-sided t.test by default.

alternative = “less” and alternative = “greater” options specify one-tailed t-test


### Run non-parametric correlation with test stats

      cor.test(variable1, variable2, method= "spearman", alternative = "two.sided", exact = FALSE)
      
      OR
      
      cor.test(variable1, variable2, method= "kendall", alternative = "two.sided", exact = FALSE)

```{r corr_spearman}

cor.test(test.frame.local$volume1, test.frame.local$volume2, method = "spearman", alternative = "two.sided", exact = FALSE)

```

OR

e.g.

```{r corr_kendall}

cor.test(test.frame.local$volume1, test.frame.local$volume2, method = "kendall", alternative = "two.sided", exact = FALSE)

```

alternative = “less” and alternative = “greater” options specify one-tailed t-test

if don't use exact argument, if will assume exact = TRUE and it will have a problem with ties. 

## t-tests

### t-test, independent, two groups	

      t.test(x~y)

e.g.

```{r ttest}

with(test.frame.3c[test.frame.3c$dx=="CON" | test.frame.3c$dx=="BV", ], t.test(age ~ dx))

```

OR

e.g. 

```{r ttest_twocol}

t.test(test.frame.local$volume1, test.frame.local$volume2)

```

This would do t-test comparing two numeric variables	Var.equal = TRUE option specifies equal variance and pooled estimate of variance

alternative = “less” and alternative = “greater” options specify one-tailed t-test

### t-test, paired	

      t.test(y1, y2, paired = TRUE)

e.g.

t-test(bpbefore, bpafter, paired = TRUE)

This would do t-test comparing two numeric variables representing repeated values from the same cases (e.g. before and after treatment)

### t-test, one sample	

      t.test(y1, mu = #)

e.g.

t-test(glucose, mu=0)

This would do t-test comparing the observed glucose values to test whether the mean is significantly different from 0

## Regression

### Run regression model	

    Object_name <- lm (dep_variable ~ indep_variable1 + indep_variable2 + indep_varialble3 + …, data = dataset_name)

e.g.

```{r regress_vol_dx_age}

lm_vol1 <- lm(test.frame.local$volume1 ~ test.frame.local$dx + test.frame.local$age)

```

This type of linear model cannot handle missing data

### View regression results	

      summary (regression_name)
e.g.

```{r show_regress}

summary(lm_vol1)

```

### Run anova on previously created linear model

      anova(regression_name)

e.g.

```{r anova_regress}

anova(lm_vol1)

```

### Get coefficients

      coefficients(model_name)

e.g.

```{r coeff_regress}

coefficients(lm_vol1)

```


### Get Confidence Intervals

      confint(model_name, level = 0.95)

e.g.

```{r conf_int}

confint(lm_vol1, level = 0.95)

```

This assumes you want 95% confidence interval. You can change level if you want

### Rerun regression with different predictors	

      Object_name(  <- update(regression_name, . ~  new_variable1, new_variable2, …)

e.g.

```{r regress_vol_dx_noage}

lm_vol1_vol2 <- update(lm_vol1, . ~ . -test.frame.local$age)
summary(lm_vol1_vol2)

```

This command will run the prior linear model without age and save to a new objects

### Compare two linear models using anova	

      anova (model1, model2)

e.g.

```{r anova_compare_regress}

anova(lm_vol1, lm_vol1_vol2)

```

### Run stepwise regression on linear model	

      Object_name <- Step(model1)
      
```{r step_vol_dx_age}

lm_vol3 <- step(lm_vol1)

```

## Power and Effect Size

### Effect size using cohen's d

Have to install the "lsr" package: install.packages("lsr")

      library(lsr)
      cohensD(variable1, variable2)
      
      OR
      
      cohensD(variable_of_interest ~ factor_variable)
      
e.g.

```{r calc_effect_size_age_dx}

library(lsr)
cohensD(test.frame.local$age ~ test.frame.local$dx)

```

The above command calculated cohen's d for the difference in age between BV and CON (that mean difference was 0.66 years with an sd of 4.06 years)

### Power analysis for t-test using effect size such as cohen's d

Have to install the "pwr" package: install.packages("pwr")

      library(pwr)
      pwr.t.test(n=sampleSize, d=cohensD, sig.level=value, power=value, type = "two.sample", alternative = "two.sided")


```{r calc_power_age_dx}

library(pwr) 
pwr.t.test(d=0.16, sig.level = 0.05, power = 0.80, type = "two.sample", alternative = "two.sided")

```

The example above used the cohen's d effect size calculated above, leaving out the n=sampleSize argument, which means you are calculating sample size. If you give it sample size and leave out power, it will calculate power.

Can substitute "one.sample" or "paired" for type, and "one.sided" for alternative.

### Power analysis for t-test using mean and sd values

      power.t.test(n=sampleSize, delta=meanDiff, sd=standardDev, sig.level=0.5, power=0.8, type ="two.sample", alternative = "two.sided")

```{r calc_power_mean_sd}

 power.t.test(delta=0.666, sd=4.06, sig.level = 0.05, power = 0.80, type = "two.sample", alternative = "two.sided")

```   

The example above calculated the sample size for each group to find a mean difference of 0.666 with a standard deviation of 4.06. You can see that the sample size estimate is fairly similar to the one above based on cohen's d and the pwr.t.test function

Can substitute "one.sample" or "paired" for type, and "one.sided" for alternative.

## Graphics and Pretty Output

### Plot data generically	P

      plot(variable1, variable2, ...)
      
      OR
      
      plot(dataset)

R will choose the appropriate plot based on the type of data you've asked it to plot

e.g.

```{r plot_generic}

 plot(test.frame.local)

```   

OR

```{r plot_age_dx}

 plot(test.frame.local$age~test.frame.local$dx)

```  

OR

e.g.

```{r plot_age_vol}

 plot(test.frame.local$age~test.frame.local$volume1)

```

### Labelling Plots

      xlab = "text"
      ylab = "text"
      main= "text"

e.g

```{r plot_age_vol_lab}

 plot(test.frame.local$age~test.frame.local$volume1, xlab="brain volume", ylab = "age", main = "Volume by Age")

```

### Boxplots

      boxplot	Boxplot(dataset_name$variable)

If you want to do conditional plot using lattice package version, use:

      bwplot(factor_variable~numeric_variable)

e.g.

```{r box_age_dx}

library(lattice)
bwplot(test.frame.local$age~test.frame.local$dx)

```

### Histograms

      hist(dataset_name$variable)

This will give counts for each interval

      hist(dataset_name$variable, prob = TRUE)

This will give probabilities for each interval instead of counts


If you want to use teh version from the lattice package:

      library(lattice)
      Histogram( ~ variable | factor_variable, data = dataset_name)

OR

      Histogram(condition ~ variable | condition, data = dataset_name, type = “statistic”, nint=number_of_bins)
      
Type can be "percent", "count", or "density"

e.g.

```{r hist_age_dx}

library(lattice)
histogram(~test.frame.local$age | test.frame.local$sex, type = "count", nint = 10)

```


### Scatterplot

      scatterplot(variable1~variable2, smoother=FALSE)
      
      OR, to separate plots by categorical variable:
      
      scatterplot(variable1~variable2 | factor_variable, smoother=FALSE)
      
e.g.

```{r scatter_age_vol_dx}

library(car)
scatterplot(test.frame.local$age~test.frame.local$volume1 | test.frame.local$dx, smoother=FALSE)

```


### Make a nice table in markdown

      library(knitr)
      knitr::kable(table_name. col_names = "column_names")
      
e.g.

The following commands will output a nice table if you run in R markdown and Knit Word. This will be able to be formatted and handled in word like any other table

```{r nice_counts_table}

sex_tab <- table(test.frame.local$sex, test.frame.local$dx)
library(knitr)
knitr::kable(sex_tab)

```

In this case, it used the names of the levels in diagnosis and sex as column names

But, you can specify the column names

e.g.

```{r nice_means_table}

means_table <- aggregate(test.frame.local$age ~ test.frame.local$dx + test.frame.local$sex, FUN=mean)
library(knitr)
knitr::kable(means_table, col.names = c("Diagnosis", "Sex", "Mean Age"))

```
